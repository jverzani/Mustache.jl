<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mustache.jl · Mustache</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Mustache</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Mustache.jl</a><ul class="internal"><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Alternatives"><span>Alternatives</span></a></li><li><a class="tocitem" href="#Differences-from-Mustache.js"><span>Differences from Mustache.js</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mustache.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mustache.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jverzani/Mustache.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mustache.jl"><a class="docs-heading-anchor" href="#Mustache.jl">Mustache.jl</a><a id="Mustache.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Mustache.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jverzani/Mustache.jl">Mustache.jl</a>.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Following the main <a href="http://mustache.github.io/mustache.5.html">documentation</a> for <code>Mustache.js</code> we have a &quot;typical Mustache template&quot; defined by:</p><pre><code class="language-julia hljs">using Mustache

tpl = mt&quot;&quot;&quot;
Hello {{name}}
You have just won {{value}} dollars!
{{#in_ca}}
Well, {{taxed_value}} dollars, after taxes.
{{/in_ca}}
&quot;&quot;&quot;</code></pre><p>The values with braces (mustaches on their side) are looked up in a view, such as a dictionary or module. For example,</p><pre><code class="language-julia hljs">d = Dict(
&quot;name&quot; =&gt; &quot;Chris&quot;,
&quot;value&quot; =&gt; 10000,
&quot;taxed_value&quot; =&gt; 10000 - (10000 * 0.4),
&quot;in_ca&quot; =&gt; true)

Mustache.render(tpl, d)</code></pre><p>Yielding</p><pre><code class="nohighlight hljs">Hello Chris
You have just won 10000 dollars!
Well, 6000.0 dollars, after taxes.</code></pre><p>The <code>render</code> function pieces things together. Like <code>print</code>, the first argument is for an optional <code>IO</code> instance. In the above example, where one is not provided, a string is returned.</p><p>The flow is</p><ul><li><p>a template is parsed into tokens by <code>Mustache.parse</code>. This can be called directly, indirectly through the non-standard string literal <code>mt</code>, or when loading a file with <code>Mustache.load</code>. The templates use tags comprised of matching mustaches (<code>{}</code>), either two or three, to indicate a value to be substituted for. These tags may be adjusted when <code>parse</code> is called.</p></li><li><p>The tokens and a view are <code>render</code>ed. The <code>render</code> function takes tokens as its second argument. If this argument is a string, <code>parse</code> is called internally. The <code>render</code> function than reassambles the template, substituting values, as appropriate, from the &quot;view&quot; passed to it and writes the output to the specified <code>io</code> argument.</p></li></ul><p>There are only 4 exports: <code>mt</code> and <code>jmt</code>, string literals to specify a template, <code>render</code>, and <code>render_from_file</code>.</p><p>The view used to provide values to substitute into the template can be specified in a variety of ways. The above example used a dictionary. A Module may also be used, such as <code>Main</code>:</p><pre><code class="language-julia hljs">name, value, taxed_value, in_ca = &quot;Christine&quot;, 10000, 10000 - (10000 * 0.4), false
Mustache.render(tpl, Main) |&gt; print</code></pre><p>Which yields:</p><pre><code class="nohighlight hljs">Hello Christine
You have just won 10000 dollars!</code></pre><p>Further, keyword arguments can be used when the variables in the templates are symbols:</p><pre><code class="language-julia hljs">goes_together = mt&quot;{{{:x}}} and {{{:y}}}.&quot;
Mustache.render(goes_together, x=&quot;Salt&quot;, y=&quot;pepper&quot;)
Mustache.render(goes_together, x=&quot;Bread&quot;, y=&quot;butter&quot;)</code></pre><p>Keyword arguments can also be passed to a <code>Tokens</code> object directly (bypassing the use of <code>render</code>):</p><pre><code class="language-julia hljs">goes_together = mt&quot;{{{:x}}} and {{{:y}}}.&quot;
goes_together(x=&quot;Fish&quot;, y=&quot;chips&quot;)</code></pre><p>Similarly, a named tuple may be used as a view.  As well, one can use Composite Kinds. This may make writing <code>show</code> methods easier:</p><pre><code class="language-julia hljs">using Distributions
tpl = &quot;Beta distribution with alpha={{α}}, beta={{β}}&quot;
Mustache.render(tpl, Beta(1, 2))</code></pre><p>gives</p><pre><code class="nohighlight hljs">&quot;Beta distribution with alpha=1.0, beta=2.0&quot;</code></pre><h3 id="Rendering"><a class="docs-heading-anchor" href="#Rendering">Rendering</a><a id="Rendering-1"></a><a class="docs-heading-anchor-permalink" href="#Rendering" title="Permalink"></a></h3><p>The <code>render</code> function combines tokens and a view to fill in the template. The basic call is <code>render([io::IO], tokens, view)</code>, however there are variants:</p><ul><li><code>render(tokens; kwargs...)</code></li><li><code>render(string, view)</code>  (<code>string</code> is parsed into tokens)</li><li><code>render(string; kwargs...)</code></li></ul><p>Finally, tokens are callable, so there are these variants to call <code>render</code>:</p><ul><li><code>tokens([io::IO], view)</code></li><li><code>tokens([io::IO]; kwargs...)</code></li></ul><h3 id="Views"><a class="docs-heading-anchor" href="#Views">Views</a><a id="Views-1"></a><a class="docs-heading-anchor-permalink" href="#Views" title="Permalink"></a></h3><p>Views are used to hold values for the templates variables. There are many possible objects that can be used for views:</p><ul><li>a dictionary</li><li>a named tuple</li><li>keyword arguments to <code>render</code></li><li>a module</li></ul><p>For templates which iterate over a variable, these can be</p><ul><li>a <code>Tables.jl</code> compatible object with row iteration support (e.g., A <code>DataFrame</code>, a tuple of named tuples, ...)</li><li>a vector or tuple (in which case &quot;<code>.</code>&quot; is used to match</li></ul><h3 id="Templates-and-tokens"><a class="docs-heading-anchor" href="#Templates-and-tokens">Templates and tokens</a><a id="Templates-and-tokens-1"></a><a class="docs-heading-anchor-permalink" href="#Templates-and-tokens" title="Permalink"></a></h3><p>A template is parsed into tokens. The <code>render</code> function combines the tokens with the view to create the output.</p><ul><li><p>Parsing is done at compile time, if the <code>mt</code> string literal is used to define the template. If re-using a template, this is encouraged, as it will be more performant.</p></li><li><p>If string interpolation is desired prior to the parsing into tokens, the <code>jmt</code> string literal can be used.</p></li><li><p>As well, a string can be used to define a template. When <code>parse</code> is called, the string will be parsed into tokens. This is the flow if <code>render</code> is called on a string (and not tokens).</p></li></ul><h3 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h3><p>Tags representing variables for substitution have the form <code>{{varname}}</code>, <code>{{:symbol}}</code>, or their triple-braced versions <code>{{{varname}}}</code> or <code>{{{:symbol}}}</code>.</p><p>The <code>varname</code> version will match variables in a view such as a dictionary or a module.</p><p>The <code>:symbol</code> version will match variables passed in via named tuple or keyword arguments.</p><pre><code class="language-julia hljs">b = &quot;be&quot;
Mustache.render(mt&quot;a {{b}} c&quot;, Main)  # &quot;a be c&quot;
Mustache.render(mt&quot;a {{:b}} c&quot;, b=&quot;bee&quot;) # &quot;a bee c&quot;
Mustache.render(mt&quot;a {{:b}} c&quot;, (b=&quot;bee&quot;, c=&quot;sea&quot;)) # &quot;a bee c&quot;</code></pre><p>The triple brace prevents HTML substitution for entities such as <code>&lt;</code>. The following are escaped when only double braces are used: &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&#39;&quot;, &quot;\&quot;, and &quot;/&quot;.</p><pre><code class="language-julia hljs">Mustache.render(mt&quot;a {{:b}} c&quot;, b = &quot;%&lt; bee &gt;%&quot;)   # &quot;a %&amp;lt; bee &amp;gt;% c&quot;
Mustache.render(mt&quot;a {{{:b}}} c&quot;, b = &quot;%&lt; bee &gt;%&quot;) # &quot;a %&lt; bee &gt;% c&quot;</code></pre><p>If different tags are specified to <code>parse</code>, say <code>&lt;&lt;</code> or <code>&gt;&gt;</code>, then <code>&lt;&lt;{</code> and <code>}&gt;&gt;</code> indicate the prevention of substitution.</p><pre><code class="language-julia hljs">tokens = Mustache.parse(&quot;a &lt;&lt;:b&gt;&gt; c&quot;, (&quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;))
Mustache.render(tokens, b = &quot;%&lt; B &gt;%&quot;)  # a %&amp;lt; B &amp;gt;% c&quot;

tokens = Mustache.parse(&quot;a &lt;&lt;{:b}&gt;&gt; c&quot;, (&quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;))
Mustache.render(tokens, b = &quot;%&lt; B &gt;%&quot;)  # &quot;a %&lt; B &gt;% c&quot;</code></pre><p>If the variable refers to a function, the value will be the result of calling the function with no arguments passed in.</p><pre><code class="language-julia hljs">Mustache.render(mt&quot;a {{:b}} c&quot;, b = () -&gt; &quot;Bea&quot;)  # &quot;a Bea c&quot;</code></pre><pre><code class="language-julia hljs">Mustache.render(mt&quot;Written in the year {{:yr}}.&quot;; yr = year∘now) # &quot;Written in the year 2022.&quot;</code></pre><h3 id="Sections"><a class="docs-heading-anchor" href="#Sections">Sections</a><a id="Sections-1"></a><a class="docs-heading-anchor-permalink" href="#Sections" title="Permalink"></a></h3><p>In the main example, the template included:</p><pre><code class="nohighlight hljs">{{#in_ca}}
Well, {{taxed_value}} dollars, after taxes.
{{/in_ca}}</code></pre><p>Tags beginning with <code>#varname</code> and closed with <code>/varname</code> create &quot;sections.&quot;  These have different behaviors depending on the value of the variable. When the variable is not a function or a container the part between them is used only if the variable is defined and not &quot;falsy:&quot;</p><pre><code class="language-julia hljs">a = mt&quot;{{#:b}}Hi{{/:b}}&quot;;
a(; b=true) # &quot;Hi&quot;
a(; c=true) # &quot;&quot;
a(; b=false) # &quot;&quot; also, as `b` is &quot;falsy&quot; (e.g., false, nothing, &quot;&quot;)</code></pre><p>If the variable name refers to a function that function will be passed the unevaluated string within the section, as expected by the Mustache specification:</p><pre><code class="language-julia hljs">Mustache.render(&quot;{{#:a}}one{{/:a}}&quot;, a=length)  # &quot;3&quot;</code></pre><p>If the tag &quot;|&quot; is used, the section value will be rendered first, an enhancement to the specification.</p><pre><code class="language-julia hljs">fmt(txt) = &quot;&lt;b&gt;&quot; * string(round(parse(Float64, txt), digits=2)) * &quot;&lt;/b&gt;&quot;;
tpl = &quot;&quot;&quot;{{|:lambda}}{{:value}}{{/:lambda}} dollars.&quot;&quot;&quot;;
Mustache.render(tpl, value=1.23456789, lambda=fmt)  # &quot;&lt;b&gt;1.23&lt;/b&gt; dollars.&quot;</code></pre><p>(Without the <code>|</code> in the tag, an error, <code>ERROR: ArgumentError: cannot parse &quot;{{:value}}&quot; as Float64</code>, will be thrown.)</p><h3 id="Inverted"><a class="docs-heading-anchor" href="#Inverted">Inverted</a><a id="Inverted-1"></a><a class="docs-heading-anchor-permalink" href="#Inverted" title="Permalink"></a></h3><p>Related, if the tag begins with <code>^varname</code> and ends with <code>/varname</code> the text between these tags is included only if the variable is <em>not</em> defined or is <code>falsy</code>.</p><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><p>If the section variable, <code>{{#varname}}</code>, binds to an iterable collection, then the text in the section is repeated for each item in the collection with the view used for the context of the template given by the item.</p><p>This is useful for collections of named objects, such as DataFrames (where the collection is comprised of rows) or arrays of dictionaries. For <code>Tables.jl</code> objects the rows are iterated over.</p><p>For data frames, the variable names are specified as symbols or strings. Here is a template for making a web page:</p><pre><code class="language-julia hljs">tpl = mt&quot;&quot;&quot;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;{{:TITLE}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;summary&lt;/th&gt;&lt;/tr&gt;
{{#:D}}
&lt;tr&gt;&lt;td&gt;{{:names}}&lt;/td&gt;&lt;td&gt;{{:summs}}&lt;/td&gt;&lt;/tr&gt;
{{/:D}}
&lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;</code></pre><p>This can be used to generate a web page for <code>whos</code>-like values:</p><pre><code class="language-julia hljs">_names = String[]
_summaries = String[]
for s in sort(map(string, names(Main)))
    v = Symbol(s)
    if isdefined(Main,v)
        push!(_names, s)
        push!(_summaries, summary(eval(v)))
    end
end

using DataFrames
d = DataFrame(names=_names, summs=_summaries)

out = Mustache.render(tpl, TITLE=&quot;A quick table&quot;, D=d)
print(out)</code></pre><p>This can be compared to using an array of <code>Dict</code>s, convenient if you have data by the row:</p><pre><code class="language-julia hljs">A = [Dict(&quot;a&quot; =&gt; &quot;eh&quot;, &quot;b&quot; =&gt; &quot;bee&quot;),
     Dict(&quot;a&quot; =&gt; &quot;ah&quot;, &quot;b&quot; =&gt; &quot;buh&quot;)]
tpl = mt&quot;{{#:A}}Pronounce a as {{a}} and b as {{b}}. {{/:A}}&quot;
Mustache.render(tpl, A=A) |&gt; print</code></pre><p>yielding</p><pre><code class="nohighlight hljs">Pronounce a as eh and b as bee. Pronounce a as ah and b as buh.</code></pre><p>The same approach can be made to make a LaTeX table from a data frame:</p><pre><code class="language-julia hljs">
function df_to_table(df, label=&quot;label&quot;, caption=&quot;caption&quot;)
    fmt = repeat(&quot;c&quot;, size(df,2))
    header = join(string.(names(df)), &quot; &amp; &quot;)
    row = join([&quot;{{:$x}}&quot; for x in map(string, names(df))], &quot; &amp; &quot;)

tpl=&quot;&quot;&quot;
\\begin{table}
  \\centering
  \\begin{tabular}{$fmt}
  $header\\\\
{{#:DF}}    $row\\\\
{{/:DF}}  \\end{tabular}
  \\caption{$caption}
  \\label{tab:$label}
\\end{table}
&quot;&quot;&quot;

    Mustache.render(tpl, DF=df)
end</code></pre><p>In the above, a string is used above – and not a <code>mt</code> macro – so that string interpolation can happen. The <code>jmt_str</code> string macro allows for substitution, so the above template could also have been more simply written as:</p><pre><code class="language-julia hljs">function df_to_table(df, label=&quot;label&quot;, caption=&quot;caption&quot;)
    fmt = repeat(&quot;c&quot;, size(df,2))
    header = join(string.(names(df)), &quot; &amp; &quot;)
    row = join([&quot;{{:$x}}&quot; for x in map(string, names(df))], &quot; &amp; &quot;)

tpl = jmt&quot;&quot;&quot;
\begin{table}
  \centering
  \begin{tabular}{$fmt}
  $header\\
{{#:DF}}    $row\\
{{/:DF}}  \end{tabular}
  \caption{$caption}
  \label{tab:$label}
\end{table}
&quot;&quot;&quot;

    Mustache.render(tpl, DF=df)
end</code></pre><h4 id="Iterating-over-vectors"><a class="docs-heading-anchor" href="#Iterating-over-vectors">Iterating over vectors</a><a id="Iterating-over-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-over-vectors" title="Permalink"></a></h4><p>Though it isn&#39;t part of the Mustache specification, when iterating over an unnamed vector or tuple, <code>Mustache.jl uses</code> <code>{{.}}</code> to refer to the item:</p><pre><code class="language-julia hljs">tpl = mt&quot;{{#:vec}}{{.}} {{/:vec}}&quot;
Mustache.render(tpl, vec = [&quot;A1&quot;, &quot;B2&quot;, &quot;C3&quot;])  # &quot;A1 B2 C3 &quot;</code></pre><p>Note the extra space after <code>C3</code>.</p><p>There is also <em>limited</em> support for indexing with the iteration of a vector that allows one to treat the last element differently. The syntax <code>.[ind]</code> refers to the value <code>vec[ind]</code>. (There is no support for the usual arithmetic on indices.)</p><p>To print commas one can use this pattern:</p><pre><code class="language-julia hljs">tpl = mt&quot;{{#:vec}}{{.}}{{^.[end]}}, {{/.[end]}}{{/:vec}}&quot;
Mustache.render(tpl, vec = [&quot;A1&quot;, &quot;B2&quot;, &quot;C3&quot;])  # &quot;A1, B2, C3&quot;</code></pre><p>To put the first value in bold, but no others, say:</p><pre><code class="language-julia hljs">tpl = mt&quot;&quot;&quot;
{{#:vec}}
{{#.[1]}}&lt;bold&gt;{{.}}&lt;/bold&gt;{{/.[1]}}
{{^.[1]}}{{.}}{{/.[1]}}
{{/:vec}}
&quot;&quot;&quot;
Mustache.render(tpl, vec = [&quot;A1&quot;, &quot;B2&quot;, &quot;C3&quot;])  # basically &quot;&lt;bold&gt;A1&lt;/bold&gt;B2 C3&quot;</code></pre><p>This was inspired by <a href="http://stackoverflow.com/questions/11147373/only-show-the-first-item-in-list-using-mustache">this</a> question, but the syntax chosen was more Julian. This syntax – as implemented for now – does not allow for iteration. That is constructs like <code>{{#.[1]}}</code> don&#39;t introduce iteration, but only offer a conditional check.</p><h3 id="Conditional-checking-without-iteration"><a class="docs-heading-anchor" href="#Conditional-checking-without-iteration">Conditional checking without iteration</a><a id="Conditional-checking-without-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-checking-without-iteration" title="Permalink"></a></h3><p>The section tag, <code>#</code>, check for existence; pushes the object into the view; and then iterates over the object. For cases where iteration is not desirable; the tag type <code>@</code> can be used.</p><p>Compare these:</p><pre><code class="language-julia hljs">julia&gt; struct RANGE
  range
end

julia&gt; tpl = mt&quot;&quot;&quot;
&lt;input type=&quot;range&quot; {{@:range}} min=&quot;{{start}}&quot; step=&quot;{{step}}&quot; max=&quot;{{stop}}&quot; {{/:range}}&gt;
&quot;&quot;&quot;;

julia&gt; Mustache.render(tpl, RANGE(1:1:2))
&quot;&lt;input type=\&quot;range\&quot;  min=\&quot;1\&quot; step=\&quot;1\&quot; max=\&quot;2\&quot; &gt;\n&quot;

julia&gt; tpl = mt&quot;&quot;&quot;
&lt;input type=&quot;range&quot; {{#:range}} min=&quot;{{start}}&quot; step=&quot;{{step}}&quot; max=&quot;{{stop}}&quot; {{/:range}}&gt;
&quot;&quot;&quot;;

julia&gt; Mustache.render(tpl, RANGE(1:1:2)) # iterates over Range.range
&quot;&lt;input type=\&quot;range\&quot;  min=\&quot;1\&quot; step=\&quot;1\&quot; max=\&quot;2\&quot;  min=\&quot;1\&quot; step=\&quot;1\&quot; max=\&quot;2\&quot; &gt;\n&quot;</code></pre><h3 id="Non-eager-finding-of-values"><a class="docs-heading-anchor" href="#Non-eager-finding-of-values">Non-eager finding of values</a><a id="Non-eager-finding-of-values-1"></a><a class="docs-heading-anchor-permalink" href="#Non-eager-finding-of-values" title="Permalink"></a></h3><p>A view might have more than one variable bound to a symbol. The first one found is replaced in the template <em>unless</em> the variable is prefaced with <code>~</code>. This example illustrates:</p><pre><code class="language-julia hljs">d = Dict(:two=&gt;Dict(:x=&gt;3), :x=&gt;2)
tpl = mt&quot;&quot;&quot;
{{#:one}}
{{#:two}}
{{~:x}}
{{/:two}}
{{/:one}}
&quot;&quot;&quot;
Mustache.render(tpl, one=d) # &quot;2\n&quot;
Mustache.render(tpl, one=d, x=1) # &quot;1\n&quot;</code></pre><p>Were <code>{{:x}}</code> used, the value <code>3</code> would have been found within the dictionary <code>Dict(:x=&gt;3)</code>; however, the presence of <code>{{~:x}}</code> is an instruction to keep looking up in the specified view to find other values, and use the last one found to substitute in. (This is hinted at in <a href="https://github.com/janl/mustache.js/issues/399">this issue</a>)</p><h3 id="Partials"><a class="docs-heading-anchor" href="#Partials">Partials</a><a id="Partials-1"></a><a class="docs-heading-anchor-permalink" href="#Partials" title="Permalink"></a></h3><p>Partials are used to include partial templates into a template.</p><p>Partials begin with a greater than sign, like <code>{{&gt; box.tpl }}</code>. In this example, the file <code>box.tpl</code> is opened and inserted into the template, then populated. A full path may be specified.</p><p>They also inherit the calling context.</p><p>In this way you may want to think of partials as includes, imports, template expansion, nested templates, or subtemplates, even though those aren&#39;t literally the case here.</p><p>The partial specified by <code>{{&lt; box.tpl }}</code> is not parsed, rather included as is into the file. This can be faster.</p><p>The variable can be a filename, as indicated above, or if not a variable. For example</p><pre><code class="language-julia hljs">julia&gt; tpl = &quot;&quot;&quot;\&quot;{{&gt;partial}}\&quot;&quot;&quot;&quot;
&quot;\&quot;{{&gt;partial}}\&quot;&quot;

julia&gt; Mustache.render(tpl, Dict(&quot;partial&quot;=&gt;&quot;*{{text}}*&quot;,&quot;text&quot;=&gt;&quot;content&quot;))
&quot;\&quot;*content*\&quot;&quot;</code></pre><h3 id="Summary-of-tags"><a class="docs-heading-anchor" href="#Summary-of-tags">Summary of tags</a><a id="Summary-of-tags-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-tags" title="Permalink"></a></h3><p>To summarize the different tags marking a variable:</p><ul><li><code>{{variable}}</code> does substitution of the value held in <code>variable</code> in the current view; escapes HTML characters</li><li><code>{{{variable}}}</code> does substitution of the value held in <code>variable</code> in the current view; does not escape HTML characters. The outer pair of mustache braces can be adjusted using <code>Mustache.parse</code>.</li><li><code>{{&amp;variable}}</code> is an alternative syntax for triple braces (useful with custom braces)</li><li><code>{{~variable}}</code> does substitution of the value held in <code>variable</code> in the outmost view</li><li><code>{{#variable}}</code> depending on the type of variable, does the following:<ul><li>if <code>variable</code> is not a functions container and is not absent or <code>nothing</code> will use the text between the matching tags, marked with <code>{{/variable}}</code>; otherwise that text will be skipped. (Like an <code>if/end</code> block.)</li><li>if <code>variable</code> is a function, it will be applied to contents of the section. Use of <code>|</code> instead of <code>#</code> will instruct the rendering of the contents before applying the function.</li><li>if <code>variable</code> is a <code>Tables.jl</code> compatible object (row wise, with named rows), will iterate over the values, pushing the named tuple to be the top-most view for the part of the template up to <code>{{\variable}}</code>.</li><li>if <code>variable</code> is a vector or tuple – for the part of the template up to <code>{{\variable}}</code> – will iterate over the values. Use <code>{{.}}</code> to refer to the (unnamed) values. The values <code>.[end]</code> and <code>.[i]</code>, for a numeric literal, will refer to values in the vector or tuple.</li></ul></li><li><code>{{^variable}}</code>/<code>{{.variable}}</code> tags will show the values when <code>variable</code> is not defined, or is <code>nothing</code>.</li><li><code>{{&gt;partial}}</code> will include the partial value into the template, filling in the template using the current view. The partial can be a variable or a filename (checked with <code>isfile</code>).</li><li><code>{{&lt;partial}}</code> directly include partial value into template without filling in with the current view.</li><li><code>{{!comment}}</code> comments begin with a bang, <code>!</code></li></ul><h2 id="Alternatives"><a class="docs-heading-anchor" href="#Alternatives">Alternatives</a><a id="Alternatives-1"></a><a class="docs-heading-anchor-permalink" href="#Alternatives" title="Permalink"></a></h2><p><code>Julia</code> provides some alternatives to this package which are better suited for many jobs:</p><ul><li><p>For simple substitution inside a string there is string <a href="https://docs.julialang.org/en/latest/manual/strings/">interpolation</a>.</p></li><li><p>For piecing together pieces of text either the <code>string</code> function or string concatenation (the <code>*</code> operator) are useful. (Also an <code>IOBuffer</code> is useful for larger tasks of this type.)</p></li><li><p>For formatting numbers and text, the <a href="https://github.com/JuliaLang/Formatting.jl">Formatting.jl</a> package, the <a href="https://github.com/JuliaString/Format.jl">Format</a> package, and the <a href="https://github.com/JuliaString/StringLiterals.jl">StringLiterals</a> package are available.</p></li><li><p>The <a href="https://github.com/MechanicalRabbit/HypertextLiteral.jl">HypertextLiteral</a> package is useful when interpolating HTML, SVG, or SGML tagged content.</p></li></ul><h2 id="Differences-from-Mustache.js"><a class="docs-heading-anchor" href="#Differences-from-Mustache.js">Differences from Mustache.js</a><a id="Differences-from-Mustache.js-1"></a><a class="docs-heading-anchor-permalink" href="#Differences-from-Mustache.js" title="Permalink"></a></h2><p>This project deviates from Mustache.js in a few significant ways:</p><ul><li><p>Julia structures are used, not JavaScript objects. As illustrated, one can use Dicts, Modules, DataFrames, functions, ...</p></li><li><p>In the Mustache spec, when lambdas are used as section names, the function is passed the unevaluated section:</p></li></ul><pre><code class="language-julia hljs">template = &quot;&lt;{{#lambda}}{{x}}{{/lambda}}&gt;&quot;
data = Dict(&quot;x&quot; =&gt; &quot;Error!&quot;, &quot;lambda&quot; =&gt; (txt) -&gt;  txt == &quot;{{x}}&quot; ? &quot;yes&quot; : &quot;no&quot;)
Mustache.render(template, data) ## &quot;&lt;yes&gt;&quot;, as txt == &quot;{{x}}&quot;</code></pre><p>The tag &quot;|&quot; is similar to the section tag &quot;#&quot;, but will receive the <em>evaluated</em> section:</p><pre><code class="language-julia hljs">template = &quot;&lt;{{|lambda}}{{x}}{{/lambda}}&gt;&quot;
data = Dict(&quot;x&quot; =&gt; &quot;Error!&quot;, &quot;lambda&quot; =&gt; (txt) -&gt;  txt == &quot;{{x}}&quot; ? &quot;yes&quot; : &quot;no&quot;)
Mustache.render(template, data) ## &quot;&lt;no&gt;&quot;, as &quot;Error!&quot; != &quot;{{x}}&quot;</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Mustache.Mustache" href="#Mustache.Mustache"><code>Mustache.Mustache</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Mustache</p><p><a href="https://github.com/jverzani/Mustache.jl">Mustache</a> is a templating package for <code>Julia</code> based on <a href="http://mustache.github.io/">Mustache.js</a>. [ <a href="https://jverzani.github.io/Mustache.jl/dev/">Docs</a> ]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/Mustache.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mustache.load-Tuple{Any, Vararg{Any}}" href="#Mustache.load-Tuple{Any, Vararg{Any}}"><code>Mustache.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Mustache.load(filepath, args...)</code></pre><p>Load file specified through  <code>filepath</code> and return the compiled tokens. Tokens are memoized for efficiency,</p><p>Additional arguments are passed to <code>Mustache.parse</code> (for adjusting the tags).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/parse.jl#L224-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mustache.parse" href="#Mustache.parse"><code>Mustache.parse</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Mustache.parse(template, tags = (&quot;{{&quot;, &quot;}}&quot;))</p><p>Parse a template into tokens.</p><ul><li><code>template</code>: a string containing a template</li><li><code>tags</code>: the tags used to indicate a variable. Adding interior braces (<code>{</code>,<code>}</code>) around the  variable will prevent HTML escaping. (That is for the default tags, <code>{{{varname}}}</code> is used; for tags like <code>(&quot;&lt;&lt;&quot;,&quot;&gt;&gt;&quot;)</code> then <code>&lt;&lt;{varname}&gt;&gt;</code> is used.)</li></ul><p><strong>Extended</strong></p><p>The template interprets tags in different ways. The string macro <code>mt</code> is used below to both <code>parse</code> (on construction) and <code>render</code> (when called).</p><p><strong>Variable substitution.</strong></p><p>Like basic string interpolation, variable subsitution can be performed using a non-prefixed tag:</p><pre><code class="language-julia-repl hljs">julia&gt; using Mustache

julia&gt; a = mt&quot;Some {{:variable}}.&quot;;

julia&gt; a(; variable=&quot;pig&quot;)
&quot;Some pig.&quot;

julia&gt; a = mt&quot;Cut: {{{:scissors}}}&quot;;

julia&gt; a(; scissors = &quot;8&lt; ... &gt;8&quot;)
&quot;Cut: 8&lt; ... &gt;8&quot;</code></pre><p>Both using a symbol, as the values to subsitute are passed through keyword arguments. The latter uses triple braces to inhibit the escaping of HTML entities.</p><p>Tags can be given special meanings through prefixes. For example, to avoid the HTML escaping an <code>&amp;</code> can be used:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;Cut: {{&amp;:scissors}}&quot;;

julia&gt; a(; scissors = &quot;8&lt; ... &gt;8&quot;)
&quot;Cut: 8&lt; ... &gt;8&quot;</code></pre><p><strong>Sections</strong></p><p>Tags can create &quot;sections&quot; which can be used to conditionally include text, apply a function to text, or iterate over the values passed to <code>render</code>.</p><p><strong>Include text</strong></p><p>To include text, the <code>#</code> prefix can open a section followed by a <code>/</code> to close the section:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;I see a {{#:ghost}}ghost{{/:ghost}}&quot;;

julia&gt; a(; ghost=true)
&quot;I see a ghost&quot;

julia&gt; a(; ghost=false)
&quot;I see a &quot;</code></pre><p>The latter is to illustrate that if the variable does not exist or is &quot;falsy&quot;, the section text will not display.</p><p>The <code>^</code> prefix shows text when the variable is not present.</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;I see {{#:ghost}}a ghost{{/:ghost}}{{^:ghost}}nothing{{/:ghost}}&quot;;

julia&gt; a(; ghost=false)
&quot;I see nothing&quot;</code></pre><p><strong>Apply a function to the text</strong></p><p>If the variable refers to a function, it will be applied to the text within the section:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;{{#:fn}}How many letters{{/:fn}}&quot;;

julia&gt; a(; fn=length)
&quot;16&quot;</code></pre><p>The use of the prefix <code>!</code> will first render the text in the section, then apply the function:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;The word &#39;{{:variable}}&#39; has {{|:fn}}{{:variable}}{{/:fn}} letters.&quot;;

julia&gt; a(; variable=&quot;length&quot;, fn=length)
&quot;The word &#39;length&#39; has 6 letters.&quot;</code></pre><p><strong>Iterate over values</strong></p><p>If the variable in a section is an iterable container, the values will be iterated over. <code>Tables.jl</code> compatible values are iterated in a row by row manner, such as this view, which is a tuple of named tuples:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;{{#:data}}x={{:x}}, y={{:y}} ... {{/:data}}&quot;;

julia&gt; a(; data=((x=1,y=2), (x=2, y=4)))
&quot;x=1, y=2 ... x=2, y=4 ... &quot;</code></pre><p>Iterables like vectors, tuples, or ranges – which have no named values – can have their values referenced by a <code>{{.}}</code> tag:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;{{#:countdown}}{{.}} ... {{/:countdown}} blastoff&quot;;

julia&gt; a(; countdown = 5:-1:1)
&quot;5 ... 4 ... 3 ... 2 ... 1 ...  blastoff&quot;</code></pre><p><strong>Partials</strong></p><p>Partials allow subsitution. The use of the tag prefex <code>&gt;</code> includes either a file or a string and renders it accordingly:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;{{&gt;:partial}}&quot;;

julia&gt; a(; partial=&quot;variable is {{:variable}}&quot;, variable=42)
&quot;variable is 42&quot;</code></pre><p>The use of the tag prefix <code>&lt;</code> just includes the partial (a file in this case) without rendering.</p><p><strong>Comments</strong></p><p>Using the tag-prefix <code>!</code> will comment out the text:</p><pre><code class="language-julia-repl hljs">julia&gt; a = mt&quot;{{! ignore this comment}}This is rendered&quot;;

julia&gt; a()
&quot;This is rendered&quot;</code></pre><p>Multi-lne comments are permitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/parse.jl#L5-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mustache.render-Tuple{IO, Mustache.MustacheTokens, Any}" href="#Mustache.render-Tuple{IO, Mustache.MustacheTokens, Any}"><code>Mustache.render</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">render([io], tokens, view)
render([io], tokens; kwargs...)
(tokens::MustacheTokens)([io]; kwargs...)</code></pre><p>Render a set of tokens with a view, using optional <code>io</code> object to print or store.</p><p><strong>Arguments</strong></p><ul><li><p><code>io::IO</code>: Optional <code>IO</code> object.</p></li><li><p><code>tokens</code>: Either Mustache tokens, or a string to parse into tokens</p></li><li><p><code>view</code>: A view provides a context to look up unresolved symbols demarcated by mustache braces. A view may be specified by a dictionary, a module, a composite type, a vector, a named tuple, a data frame, a <code>Tables</code> object, or keyword arguments.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>render</code> method is currently exported, but this export may be deprecated in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/render.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mustache.render_from_file-Tuple{Any, Any}" href="#Mustache.render_from_file-Tuple{Any, Any}"><code>Mustache.render_from_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">render_from_file(filepath, view)
render_from_file(filepath; kwargs...)</code></pre><p>Renders a template from <code>filepath</code> and <code>view</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function simply combines <code>Mustache.render</code> and <code>Mustache.load</code> and may be deprecated in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/render.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mustache.@jmt_str-Tuple{String}" href="#Mustache.@jmt_str-Tuple{String}"><code>Mustache.@jmt_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">jmt&quot;string&quot;</code></pre><p>String macro that interpolates values escaped by dollar signs, then parses strings.</p><p>Note: modified from a macro in <a href="https://github.com/clarkevans/HypertextLiteral.jl/blob/master/src/macros.jl">HypertextLiteral</a>.</p><p>Example:</p><pre><code class="nohighlight hljs">x = 1
toks = jmt&quot;$(2x) by {{:a}}&quot;
toks(; a=2) # &quot;2 by 2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/parse.jl#L161-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mustache.@mt_str-Tuple{Any}" href="#Mustache.@mt_str-Tuple{Any}"><code>Mustache.@mt_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">mt&quot;string&quot;</code></pre><p>String macro to parse tokens from a string. See <a href="#Mustache.parse"><code>parse</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/Mustache.jl/blob/d71b8b41efba67e7e1a9be7e24080e34c6e47079/src/parse.jl#L150-L155">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Monday 18 July 2022 19:26">Monday 18 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
